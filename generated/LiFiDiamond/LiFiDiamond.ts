// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class DiamondCut extends ethereum.Event {
  get params(): DiamondCut__Params {
    return new DiamondCut__Params(this);
  }
}

export class DiamondCut__Params {
  _event: DiamondCut;

  constructor(event: DiamondCut) {
    this._event = event;
  }

  get _diamondCut(): Array<DiamondCut_diamondCutStruct> {
    return this._event.parameters[0].value.toTupleArray<
      DiamondCut_diamondCutStruct
    >();
  }

  get _init(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _calldata(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class DiamondCut_diamondCutStruct extends ethereum.Tuple {
  get facetAddress(): Address {
    return this[0].toAddress();
  }

  get action(): i32 {
    return this[1].toI32();
  }

  get functionSelectors(): Array<Bytes> {
    return this[2].toBytesArray();
  }
}

export class LiFiTransferCompleted extends ethereum.Event {
  get params(): LiFiTransferCompleted__Params {
    return new LiFiTransferCompleted__Params(this);
  }
}

export class LiFiTransferCompleted__Params {
  _event: LiFiTransferCompleted;

  constructor(event: LiFiTransferCompleted) {
    this._event = event;
  }

  get transactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get receivingAssetId(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class LiFiTransferStarted extends ethereum.Event {
  get params(): LiFiTransferStarted__Params {
    return new LiFiTransferStarted__Params(this);
  }
}

export class LiFiTransferStarted__Params {
  _event: LiFiTransferStarted;

  constructor(event: LiFiTransferStarted) {
    this._event = event;
  }

  get transactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get integrator(): string {
    return this._event.parameters[1].value.toString();
  }

  get referrer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get sendingAssetId(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get receivingAssetId(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get destinationChainId(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }
}

export class LiFiTransferCompleted1 extends ethereum.Event {
  get params(): LiFiTransferCompleted1__Params {
    return new LiFiTransferCompleted1__Params(this);
  }
}

export class LiFiTransferCompleted1__Params {
  _event: LiFiTransferCompleted1;

  constructor(event: LiFiTransferCompleted1) {
    this._event = event;
  }

  get transactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get receivingAssetId(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class LiFiTransferStarted1 extends ethereum.Event {
  get params(): LiFiTransferStarted1__Params {
    return new LiFiTransferStarted1__Params(this);
  }
}

export class LiFiTransferStarted1__Params {
  _event: LiFiTransferStarted1;

  constructor(event: LiFiTransferStarted1) {
    this._event = event;
  }

  get transactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get integrator(): string {
    return this._event.parameters[1].value.toString();
  }

  get referrer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get sendingAssetId(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get receivingAssetId(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get destinationChainId(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }
}

export class NXTPBridgeStarted extends ethereum.Event {
  get params(): NXTPBridgeStarted__Params {
    return new NXTPBridgeStarted__Params(this);
  }
}

export class NXTPBridgeStarted__Params {
  _event: NXTPBridgeStarted;

  constructor(event: NXTPBridgeStarted) {
    this._event = event;
  }

  get lifiTransactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get nxtpTransactionId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get txData(): NXTPBridgeStartedTxDataStruct {
    return this._event.parameters[2].value.toTuple() as NXTPBridgeStartedTxDataStruct;
  }
}

export class NXTPBridgeStartedTxDataStruct extends ethereum.Tuple {
  get receivingChainTxManagerAddress(): Address {
    return this[0].toAddress();
  }

  get user(): Address {
    return this[1].toAddress();
  }

  get router(): Address {
    return this[2].toAddress();
  }

  get initiator(): Address {
    return this[3].toAddress();
  }

  get sendingAssetId(): Address {
    return this[4].toAddress();
  }

  get receivingAssetId(): Address {
    return this[5].toAddress();
  }

  get sendingChainFallback(): Address {
    return this[6].toAddress();
  }

  get receivingAddress(): Address {
    return this[7].toAddress();
  }

  get callTo(): Address {
    return this[8].toAddress();
  }

  get callDataHash(): Bytes {
    return this[9].toBytes();
  }

  get transactionId(): Bytes {
    return this[10].toBytes();
  }

  get sendingChainId(): BigInt {
    return this[11].toBigInt();
  }

  get receivingChainId(): BigInt {
    return this[12].toBigInt();
  }

  get amount(): BigInt {
    return this[13].toBigInt();
  }

  get expiry(): BigInt {
    return this[14].toBigInt();
  }

  get preparedBlockNumber(): BigInt {
    return this[15].toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LogWithdraw extends ethereum.Event {
  get params(): LogWithdraw__Params {
    return new LogWithdraw__Params(this);
  }
}

export class LogWithdraw__Params {
  _event: LogWithdraw;

  constructor(event: LogWithdraw) {
    this._event = event;
  }

  get _assetAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class DiamondCut1 extends ethereum.Event {
  get params(): DiamondCut1__Params {
    return new DiamondCut1__Params(this);
  }
}

export class DiamondCut1__Params {
  _event: DiamondCut1;

  constructor(event: DiamondCut1) {
    this._event = event;
  }

  get _diamondCut(): Array<DiamondCut1_diamondCutStruct> {
    return this._event.parameters[0].value.toTupleArray<
      DiamondCut1_diamondCutStruct
    >();
  }

  get _init(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _calldata(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class DiamondCut1_diamondCutStruct extends ethereum.Tuple {
  get facetAddress(): Address {
    return this[0].toAddress();
  }

  get action(): i32 {
    return this[1].toI32();
  }

  get functionSelectors(): Array<Bytes> {
    return this[2].toBytesArray();
  }
}

export class OwnershipTransferred1 extends ethereum.Event {
  get params(): OwnershipTransferred1__Params {
    return new OwnershipTransferred1__Params(this);
  }
}

export class OwnershipTransferred1__Params {
  _event: OwnershipTransferred1;

  constructor(event: OwnershipTransferred1) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class AssetSwapped extends ethereum.Event {
  get params(): AssetSwapped__Params {
    return new AssetSwapped__Params(this);
  }
}

export class AssetSwapped__Params {
  _event: AssetSwapped;

  constructor(event: AssetSwapped) {
    this._event = event;
  }

  get transactionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get dex(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get fromAssetId(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get toAssetId(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get fromAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get toAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class LiFiDiamond__facetsResultFacets_Struct extends ethereum.Tuple {
  get facetAddress(): Address {
    return this[0].toAddress();
  }

  get functionSelectors(): Array<Bytes> {
    return this[1].toBytesArray();
  }
}

export class LiFiDiamond extends ethereum.SmartContract {
  static bind(address: Address): LiFiDiamond {
    return new LiFiDiamond("LiFiDiamond", address);
  }

  facetAddress(_functionSelector: Bytes): Address {
    let result = super.call("facetAddress", "facetAddress(bytes4):(address)", [
      ethereum.Value.fromFixedBytes(_functionSelector)
    ]);

    return result[0].toAddress();
  }

  try_facetAddress(_functionSelector: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "facetAddress",
      "facetAddress(bytes4):(address)",
      [ethereum.Value.fromFixedBytes(_functionSelector)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  facetAddresses(): Array<Address> {
    let result = super.call(
      "facetAddresses",
      "facetAddresses():(address[])",
      []
    );

    return result[0].toAddressArray();
  }

  try_facetAddresses(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "facetAddresses",
      "facetAddresses():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  facetFunctionSelectors(_facet: Address): Array<Bytes> {
    let result = super.call(
      "facetFunctionSelectors",
      "facetFunctionSelectors(address):(bytes4[])",
      [ethereum.Value.fromAddress(_facet)]
    );

    return result[0].toBytesArray();
  }

  try_facetFunctionSelectors(
    _facet: Address
  ): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "facetFunctionSelectors",
      "facetFunctionSelectors(address):(bytes4[])",
      [ethereum.Value.fromAddress(_facet)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  facets(): Array<LiFiDiamond__facetsResultFacets_Struct> {
    let result = super.call("facets", "facets():((address,bytes4[])[])", []);

    return result[0].toTupleArray<LiFiDiamond__facetsResultFacets_Struct>();
  }

  try_facets(): ethereum.CallResult<
    Array<LiFiDiamond__facetsResultFacets_Struct>
  > {
    let result = super.tryCall("facets", "facets():((address,bytes4[])[])", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<LiFiDiamond__facetsResultFacets_Struct>()
    );
  }

  supportsInterface(_interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(_interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(_interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(_interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getNXTPTransactionManager(): Address {
    let result = super.call(
      "getNXTPTransactionManager",
      "getNXTPTransactionManager():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getNXTPTransactionManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getNXTPTransactionManager",
      "getNXTPTransactionManager():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class DiamondCutCall extends ethereum.Call {
  get inputs(): DiamondCutCall__Inputs {
    return new DiamondCutCall__Inputs(this);
  }

  get outputs(): DiamondCutCall__Outputs {
    return new DiamondCutCall__Outputs(this);
  }
}

export class DiamondCutCall__Inputs {
  _call: DiamondCutCall;

  constructor(call: DiamondCutCall) {
    this._call = call;
  }

  get _diamondCut(): Array<DiamondCutCall_diamondCutStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      DiamondCutCall_diamondCutStruct
    >();
  }

  get _init(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _calldata(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class DiamondCutCall__Outputs {
  _call: DiamondCutCall;

  constructor(call: DiamondCutCall) {
    this._call = call;
  }
}

export class DiamondCutCall_diamondCutStruct extends ethereum.Tuple {
  get facetAddress(): Address {
    return this[0].toAddress();
  }

  get action(): i32 {
    return this[1].toI32();
  }

  get functionSelectors(): Array<Bytes> {
    return this[2].toBytesArray();
  }
}

export class StartBridgeTokensViaHopCall extends ethereum.Call {
  get inputs(): StartBridgeTokensViaHopCall__Inputs {
    return new StartBridgeTokensViaHopCall__Inputs(this);
  }

  get outputs(): StartBridgeTokensViaHopCall__Outputs {
    return new StartBridgeTokensViaHopCall__Outputs(this);
  }
}

export class StartBridgeTokensViaHopCall__Inputs {
  _call: StartBridgeTokensViaHopCall;

  constructor(call: StartBridgeTokensViaHopCall) {
    this._call = call;
  }

  get _lifiData(): StartBridgeTokensViaHopCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as StartBridgeTokensViaHopCall_lifiDataStruct;
  }

  get _hopData(): StartBridgeTokensViaHopCall_hopDataStruct {
    return this._call.inputValues[1].value.toTuple() as StartBridgeTokensViaHopCall_hopDataStruct;
  }
}

export class StartBridgeTokensViaHopCall__Outputs {
  _call: StartBridgeTokensViaHopCall;

  constructor(call: StartBridgeTokensViaHopCall) {
    this._call = call;
  }
}

export class StartBridgeTokensViaHopCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class StartBridgeTokensViaHopCall_hopDataStruct extends ethereum.Tuple {
  get chainId(): BigInt {
    return this[0].toBigInt();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get relayerFee(): BigInt {
    return this[2].toBigInt();
  }

  get assetId(): Address {
    return this[3].toAddress();
  }

  get recipient(): Address {
    return this[4].toAddress();
  }
}

export class SwapAndStartBridgeTokensViaHopCall extends ethereum.Call {
  get inputs(): SwapAndStartBridgeTokensViaHopCall__Inputs {
    return new SwapAndStartBridgeTokensViaHopCall__Inputs(this);
  }

  get outputs(): SwapAndStartBridgeTokensViaHopCall__Outputs {
    return new SwapAndStartBridgeTokensViaHopCall__Outputs(this);
  }
}

export class SwapAndStartBridgeTokensViaHopCall__Inputs {
  _call: SwapAndStartBridgeTokensViaHopCall;

  constructor(call: SwapAndStartBridgeTokensViaHopCall) {
    this._call = call;
  }

  get _lifiData(): SwapAndStartBridgeTokensViaHopCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as SwapAndStartBridgeTokensViaHopCall_lifiDataStruct;
  }

  get _swapData(): Array<SwapAndStartBridgeTokensViaHopCall_swapDataStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      SwapAndStartBridgeTokensViaHopCall_swapDataStruct
    >();
  }

  get _hopData(): SwapAndStartBridgeTokensViaHopCall_hopDataStruct {
    return this._call.inputValues[2].value.toTuple() as SwapAndStartBridgeTokensViaHopCall_hopDataStruct;
  }
}

export class SwapAndStartBridgeTokensViaHopCall__Outputs {
  _call: SwapAndStartBridgeTokensViaHopCall;

  constructor(call: SwapAndStartBridgeTokensViaHopCall) {
    this._call = call;
  }
}

export class SwapAndStartBridgeTokensViaHopCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class SwapAndStartBridgeTokensViaHopCall_swapDataStruct extends ethereum.Tuple {
  get callTo(): Address {
    return this[0].toAddress();
  }

  get sendingAssetId(): Address {
    return this[1].toAddress();
  }

  get receivingAssetId(): Address {
    return this[2].toAddress();
  }

  get fromAmount(): BigInt {
    return this[3].toBigInt();
  }

  get callData(): Bytes {
    return this[4].toBytes();
  }
}

export class SwapAndStartBridgeTokensViaHopCall_hopDataStruct extends ethereum.Tuple {
  get chainId(): BigInt {
    return this[0].toBigInt();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get relayerFee(): BigInt {
    return this[2].toBigInt();
  }

  get assetId(): Address {
    return this[3].toAddress();
  }

  get recipient(): Address {
    return this[4].toAddress();
  }
}

export class CompleteBridgeTokensViaNXTPCall extends ethereum.Call {
  get inputs(): CompleteBridgeTokensViaNXTPCall__Inputs {
    return new CompleteBridgeTokensViaNXTPCall__Inputs(this);
  }

  get outputs(): CompleteBridgeTokensViaNXTPCall__Outputs {
    return new CompleteBridgeTokensViaNXTPCall__Outputs(this);
  }
}

export class CompleteBridgeTokensViaNXTPCall__Inputs {
  _call: CompleteBridgeTokensViaNXTPCall;

  constructor(call: CompleteBridgeTokensViaNXTPCall) {
    this._call = call;
  }

  get _lifiData(): CompleteBridgeTokensViaNXTPCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as CompleteBridgeTokensViaNXTPCall_lifiDataStruct;
  }

  get assetId(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get receiver(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class CompleteBridgeTokensViaNXTPCall__Outputs {
  _call: CompleteBridgeTokensViaNXTPCall;

  constructor(call: CompleteBridgeTokensViaNXTPCall) {
    this._call = call;
  }
}

export class CompleteBridgeTokensViaNXTPCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class StartBridgeTokensViaNXTPCall extends ethereum.Call {
  get inputs(): StartBridgeTokensViaNXTPCall__Inputs {
    return new StartBridgeTokensViaNXTPCall__Inputs(this);
  }

  get outputs(): StartBridgeTokensViaNXTPCall__Outputs {
    return new StartBridgeTokensViaNXTPCall__Outputs(this);
  }
}

export class StartBridgeTokensViaNXTPCall__Inputs {
  _call: StartBridgeTokensViaNXTPCall;

  constructor(call: StartBridgeTokensViaNXTPCall) {
    this._call = call;
  }

  get _lifiData(): StartBridgeTokensViaNXTPCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as StartBridgeTokensViaNXTPCall_lifiDataStruct;
  }

  get _nxtpData(): StartBridgeTokensViaNXTPCall_nxtpDataStruct {
    return this._call.inputValues[1].value.toTuple() as StartBridgeTokensViaNXTPCall_nxtpDataStruct;
  }
}

export class StartBridgeTokensViaNXTPCall__Outputs {
  _call: StartBridgeTokensViaNXTPCall;

  constructor(call: StartBridgeTokensViaNXTPCall) {
    this._call = call;
  }
}

export class StartBridgeTokensViaNXTPCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class StartBridgeTokensViaNXTPCall_nxtpDataStruct extends ethereum.Tuple {
  get invariantData(): StartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct {
    return this[0].toTuple() as StartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct;
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get encryptedCallData(): Bytes {
    return this[3].toBytes();
  }

  get encodedBid(): Bytes {
    return this[4].toBytes();
  }

  get bidSignature(): Bytes {
    return this[5].toBytes();
  }

  get encodedMeta(): Bytes {
    return this[6].toBytes();
  }
}

export class StartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct extends ethereum.Tuple {
  get receivingChainTxManagerAddress(): Address {
    return this[0].toAddress();
  }

  get user(): Address {
    return this[1].toAddress();
  }

  get router(): Address {
    return this[2].toAddress();
  }

  get initiator(): Address {
    return this[3].toAddress();
  }

  get sendingAssetId(): Address {
    return this[4].toAddress();
  }

  get receivingAssetId(): Address {
    return this[5].toAddress();
  }

  get sendingChainFallback(): Address {
    return this[6].toAddress();
  }

  get receivingAddress(): Address {
    return this[7].toAddress();
  }

  get callTo(): Address {
    return this[8].toAddress();
  }

  get sendingChainId(): BigInt {
    return this[9].toBigInt();
  }

  get receivingChainId(): BigInt {
    return this[10].toBigInt();
  }

  get callDataHash(): Bytes {
    return this[11].toBytes();
  }

  get transactionId(): Bytes {
    return this[12].toBytes();
  }
}

export class SwapAndCompleteBridgeTokensViaNXTPCall extends ethereum.Call {
  get inputs(): SwapAndCompleteBridgeTokensViaNXTPCall__Inputs {
    return new SwapAndCompleteBridgeTokensViaNXTPCall__Inputs(this);
  }

  get outputs(): SwapAndCompleteBridgeTokensViaNXTPCall__Outputs {
    return new SwapAndCompleteBridgeTokensViaNXTPCall__Outputs(this);
  }
}

export class SwapAndCompleteBridgeTokensViaNXTPCall__Inputs {
  _call: SwapAndCompleteBridgeTokensViaNXTPCall;

  constructor(call: SwapAndCompleteBridgeTokensViaNXTPCall) {
    this._call = call;
  }

  get _lifiData(): SwapAndCompleteBridgeTokensViaNXTPCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as SwapAndCompleteBridgeTokensViaNXTPCall_lifiDataStruct;
  }

  get _swapData(): Array<
    SwapAndCompleteBridgeTokensViaNXTPCall_swapDataStruct
  > {
    return this._call.inputValues[1].value.toTupleArray<
      SwapAndCompleteBridgeTokensViaNXTPCall_swapDataStruct
    >();
  }

  get finalAssetId(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get receiver(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class SwapAndCompleteBridgeTokensViaNXTPCall__Outputs {
  _call: SwapAndCompleteBridgeTokensViaNXTPCall;

  constructor(call: SwapAndCompleteBridgeTokensViaNXTPCall) {
    this._call = call;
  }
}

export class SwapAndCompleteBridgeTokensViaNXTPCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class SwapAndCompleteBridgeTokensViaNXTPCall_swapDataStruct extends ethereum.Tuple {
  get callTo(): Address {
    return this[0].toAddress();
  }

  get sendingAssetId(): Address {
    return this[1].toAddress();
  }

  get receivingAssetId(): Address {
    return this[2].toAddress();
  }

  get fromAmount(): BigInt {
    return this[3].toBigInt();
  }

  get callData(): Bytes {
    return this[4].toBytes();
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall extends ethereum.Call {
  get inputs(): SwapAndStartBridgeTokensViaNXTPCall__Inputs {
    return new SwapAndStartBridgeTokensViaNXTPCall__Inputs(this);
  }

  get outputs(): SwapAndStartBridgeTokensViaNXTPCall__Outputs {
    return new SwapAndStartBridgeTokensViaNXTPCall__Outputs(this);
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall__Inputs {
  _call: SwapAndStartBridgeTokensViaNXTPCall;

  constructor(call: SwapAndStartBridgeTokensViaNXTPCall) {
    this._call = call;
  }

  get _lifiData(): SwapAndStartBridgeTokensViaNXTPCall_lifiDataStruct {
    return this._call.inputValues[0].value.toTuple() as SwapAndStartBridgeTokensViaNXTPCall_lifiDataStruct;
  }

  get _swapData(): Array<SwapAndStartBridgeTokensViaNXTPCall_swapDataStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      SwapAndStartBridgeTokensViaNXTPCall_swapDataStruct
    >();
  }

  get _nxtpData(): SwapAndStartBridgeTokensViaNXTPCall_nxtpDataStruct {
    return this._call.inputValues[2].value.toTuple() as SwapAndStartBridgeTokensViaNXTPCall_nxtpDataStruct;
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall__Outputs {
  _call: SwapAndStartBridgeTokensViaNXTPCall;

  constructor(call: SwapAndStartBridgeTokensViaNXTPCall) {
    this._call = call;
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall_lifiDataStruct extends ethereum.Tuple {
  get transactionId(): Bytes {
    return this[0].toBytes();
  }

  get integrator(): string {
    return this[1].toString();
  }

  get referrer(): Address {
    return this[2].toAddress();
  }

  get sendingAssetId(): Address {
    return this[3].toAddress();
  }

  get receivingAssetId(): Address {
    return this[4].toAddress();
  }

  get receiver(): Address {
    return this[5].toAddress();
  }

  get destinationChainId(): BigInt {
    return this[6].toBigInt();
  }

  get amount(): BigInt {
    return this[7].toBigInt();
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall_swapDataStruct extends ethereum.Tuple {
  get callTo(): Address {
    return this[0].toAddress();
  }

  get sendingAssetId(): Address {
    return this[1].toAddress();
  }

  get receivingAssetId(): Address {
    return this[2].toAddress();
  }

  get fromAmount(): BigInt {
    return this[3].toBigInt();
  }

  get callData(): Bytes {
    return this[4].toBytes();
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall_nxtpDataStruct extends ethereum.Tuple {
  get invariantData(): SwapAndStartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct {
    return this[0].toTuple() as SwapAndStartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct;
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get encryptedCallData(): Bytes {
    return this[3].toBytes();
  }

  get encodedBid(): Bytes {
    return this[4].toBytes();
  }

  get bidSignature(): Bytes {
    return this[5].toBytes();
  }

  get encodedMeta(): Bytes {
    return this[6].toBytes();
  }
}

export class SwapAndStartBridgeTokensViaNXTPCall_nxtpDataInvariantDataStruct extends ethereum.Tuple {
  get receivingChainTxManagerAddress(): Address {
    return this[0].toAddress();
  }

  get user(): Address {
    return this[1].toAddress();
  }

  get router(): Address {
    return this[2].toAddress();
  }

  get initiator(): Address {
    return this[3].toAddress();
  }

  get sendingAssetId(): Address {
    return this[4].toAddress();
  }

  get receivingAssetId(): Address {
    return this[5].toAddress();
  }

  get sendingChainFallback(): Address {
    return this[6].toAddress();
  }

  get receivingAddress(): Address {
    return this[7].toAddress();
  }

  get callTo(): Address {
    return this[8].toAddress();
  }

  get sendingChainId(): BigInt {
    return this[9].toBigInt();
  }

  get receivingChainId(): BigInt {
    return this[10].toBigInt();
  }

  get callDataHash(): Bytes {
    return this[11].toBytes();
  }

  get transactionId(): Bytes {
    return this[12].toBytes();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get _assetAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}
