type LiFiTransfer @entity {
  id: ID!
  integrator: String!
  referrer: Bytes!
  sendingAssetId: Bytes!
  receivingAssetId: Bytes!
  receiver: Bytes!
  amount: BigInt!
  destinationChainId: BigInt!
  timestamp: BigInt!
}

# enum TransactionStatus {
#   Prepared
#   Fulfilled
#   Cancelled
# }

# # Transaction represents a transaction
# type Transaction @entity {
#   id: ID!
#   # Subgraph Meta
#   status: TransactionStatus!
#   chainId: BigInt!
#   preparedTimestamp: BigInt!

#   # TransactionData
#   receivingChainTxManagerAddress: Bytes!
#   user: User!
#   router: Router!
#   sendingAssetId: Bytes!
#   receivingAssetId: Bytes!
#   sendingChainFallback: Bytes!
#   callTo: Bytes!
#   receivingAddress: Bytes!
#   callDataHash: Bytes!
#   transactionId: Bytes!
#   sendingChainId: BigInt!
#   receivingChainId: BigInt!
#   amount: BigInt!
#   expiry: BigInt!
#   preparedBlockNumber: BigInt!

#   # TransactionPrepared
#   encryptedCallData: String!
#   prepareCaller: Bytes
#   bidSignature: Bytes!
#   encodedBid: Bytes!
#   prepareTransactionHash: Bytes!

#   # TransactionFulfilled
#   relayerFee: BigInt
#   signature: Bytes
#   callData: String
#   externalCallSuccess: Boolean
#   externalCallReturnData: Bytes
#   fulfillCaller: Bytes
#   fulfillTransactionHash: Bytes
#   fulfillTimestamp: BigInt
#   # fulfillBlockNumber: BigInt!

#   # TransactionCancelled
#   cancelCaller: Bytes
#   cancelTransactionHash: Bytes
# }

# # User entity keeps track of active user transactions
# type User @entity {
#   id: ID!
#   transactions: [Transaction!]! @derivedFrom(field: "user")
# }
